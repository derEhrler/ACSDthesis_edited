\chapter{Grundlagen} \label{chap:Grundlagen}
\thispagestyle{empty}
In diesem Kapitel wird zunächst eine Einführung in alle Themenbereiche gegeben. Insbesondere wird der modellprädiktive Pfadfolgeregler näher erläutert, um ein besseres Systemverständnis zu erlangen. Außerdem wird auf  Strategien für das Überprüfen von Software und Testabläufe, speziell in der Automobilindustrie, näher eingegangen und ein Einblick in aktuelle Softwarentwicklungsabläufe gegeben. 
\section{Modellprädiktive Pfadfolgeregelung} \label{sec:MPFC}
\subsection{Modellprädiktive Regelung}
Die modellprädiktive Regelung (engl. Model Predictive Control, MPC) ist ein Verfahren zur Regelung von dynamischen Systemen. Dabei wird ein mathematisches Modell des Systems erstellt. Durch das messen und beobachten des Ausgangszustandes können über die Gleichung \ref{eq:mpc_schema} die zukünftigen Systemzustände $x$ und Ausgänge $y
$ innerhalb des Prädiktionshorizont $n_p$ vorhergesagt werden. Das prädizierte Systemverhalten wird dann verwendet, um ein Optimalsteuerungsproblem (engl. Optimal Control Problem - OCP) zu lösen und die optimale Eingabe zu finden um das System in einen gewünschten Zustand zu bringen.
\begin{equation}
    \begin{split}
        x(k+1)  &= f(x(k), u(k)) \\
        y(k)    &= g(x(k), u(k))
    \end{split}
    \label{eq:mpc_schema}
\end{equation}
Der Ablauf einer modellprädiktiven Regelung wie in Abbildung \ref{fig:MPC} kann in drei Punkte unterteilt werden \cite{camacho2013model}:
\begin{enumerate}
    \item Mithilfe eines Modells wird der Ausgang eines Systems $y(k+i)$ für die nächsten $i = 1, ..., n_p$ Zeitschritte vorausgesagt. Grundlage für die Prädiktion sind die aktuellen Systemzustände und -eingänge und die zukünftigen Eingänge, welche im nächsten Schritt berechnet werden.
    \item Innerhalb des Stellhorizonts $n_c$, wobei $n_c \leq n_p$, wird die Stellgrößensequenz $u$ berechnet. Dabei wird eine Kostenfunktion, beispielsweise Gleichung \ref{eq:cost_function} mit den Wichtungen $Q$, welche die Abweichung vom Referenzverlauf bestraft und $r$, welche den Stellaufwand berücksichtigt, so gewählt, dass sich ein gewünschtes Systemverhalten einstellt. Häufig wird dabei ein quadratisches Gütemaß verwendet. Ebenfalls können Beschränkungen, von z.B. den Eingangsgrößen, berücksichtigt werden. Für jeden Zeitschritt wird so das OCP gelöst.
    \item Das erste Element des Stellhorizonts wird auf das System angewendet. Stell- und Prädiktionshorizont verschieben sich um einen Zeitschritt in die Zukunft. Der Zyklus beginnt von vorn. 
\end{enumerate}
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/2_Grundlagen/MPC_Diagramm.png}
    \caption{Ablauf einer modellprädiktiven Regelung \cite{adamy2014}}
    \label{fig:MPC}
\end{figure}
\begin{equation}
    J = \sum_{i=1}^{n_p} \left\| Q \left( y(k+i) - y_R(k+i) \right) \right\|^2 + r \cdot \sum_{i=1}^{n_p} \left\| u(k+i-1) \right\|^2
    \label{eq:cost_function}
\end{equation}

\subsection{Pfadfolgeregelung}
Die Struktur der modellprädiktiven Pfadfolgeregelung, für die in diesem Praktikum eine Teststrategie implementiert werden soll, ist in Abbildung \ref{fig:MPFC_Schema} dargestellt und in \cite{ritschel2019} dokumentiert. Als Eingänge dienen der MPFC eine vorgegebene Sollgeschwindigkeit, Pfaddaten, Fahrzeugzustände, vorgegebene Beschränkungen und ein Fahrzeugmodell. Als Ausgang werden Sollbeschleunigung und Solllenkradwinkelgeschwindigkeit berechnet. Die Grundidee der Pfadfolgeregelung ist in \cite{Faulwasser2009} beschrieben. Der Regler soll einem vorgegebenen Pfad möglichst gut folgen. Im Gegensatz zu trajektorienbasierten Ansätzen ist dabei nicht vorgegeben, wann das System an welcher Stelle des Pfades sein soll. Die Regelung der Längsgeschwindigkeit ist daher zusätzlich erforderlich. \medskip

\noindent Betrachtet wird das zeitkontinuierliche, nichtlineare System der Form 
\begin{align}
    \dot{x}(t)  &= f(x(t),u(t)), x(t_0)= x_0\\
    y(t)        &= h(x(t)) 
\end{align}
mit den Zuständen $x\in\mathcal{X}\subseteq\mathbb{R}^{N_x}$, Eingängen $u\in\mathcal{U}\subseteq\mathbb{R}^{N_u}$ und dem Ausgang $y\in\mathcal{Y}\subseteq\mathbb{R}^{N_y}$.
 
Die geometrische Kurve $\mathcal{P}:\{p(\theta)\in\mathbb{R}^{N_y}|\theta\in[\theta_0,\theta_1]\mapsto p(\theta)\}$ ist als Referenzpfad gegeben und wird durch $p(\theta)$ parametrisiert.
\begin{equation}
    p(\theta) = 
    \begin{bmatrix}
        x_{\text{ref}}(\theta) \\
        y_{\text{ref}}(\theta) \\
        \psi_{\text{ref}}(\theta)
    \end{bmatrix}    
\end{equation}
Der Pfadparameter $\theta$ gibt die Position auf dem Referenzpfad an. Dieser wird als ein virtueller Zustand von einem zusätzlichen Eingang, der Geschwindigkeit $\vartheta\in\mathcal{V}\subseteq\mathbb{R}$, beeinflusst. Dadurch ist eine Geschwindigkeitszuweisung möglich.
\begin{equation}
    \dot{\theta}(t)=\vartheta(t)
\end{equation}

Es kann nun ein Regler für das lösen des Pfadfolgeproblems mit Geschwindigkeitszuweisung entworfen werden, der folgende Eigenschaften besitzt:
\begin{enumerate}
    \item Der Ausgang des Systems $y$ konvergiert auf den Pfad $\mathcal{P}$: $\lim \limits_{t \to \infty} \|e(t)\| = 0$ mit der Pfadabweichung $e(t) := h(x(t)) - p(\theta(t))$.
    \item Die Pfadgeschwindigkeit konvergiert auf die Referenzgeschwindigkeit: $\lim \limits_{t \to \infty} \|\bar{\theta}(t)-\bar{\theta}_{ref}(t)\| = 0$
    \item Die Zustandsbeschränkungen $\mathcal{X}$ und Eingangsgrößenbeschränkungen $\mathcal{U}$ werden eingehalten.
\end{enumerate}

\medskip
\noindent Das OCP, welches zu jedem diskreten Zeitpunkt $t_k=kT_s$ mit der Samplingzeit $T_s$ gelöst werden soll ist folgendes:
\begin{subequations}
\begin{align}
    J(x(t_k),\theta(t_k),\bar{u}^{*}(\cdot),\bar{\vartheta}^{*}(\cdot)) = &\underset{u(\cdot), \vartheta(\cdot)}{\min} J(x(t_k), \theta(t_k), \bar{u}(\cdot), \bar{\vartheta}(\cdot)) \label{eq:minProblemA}\\
    s.t \hspace{30pt} &\dot{\bar{x}}(\tau) = f(\bar{x}(\tau), \bar{u}(\tau)), \quad \bar{x}(t_k) = x(t_k) \label{eq:minProblemB}\\
    &\dot{\bar{\theta}}(\tau) = \bar{\vartheta}(\tau), \quad \bar{\theta}(t_k) = \theta(t_k) \label{eq:minProblemC}\\
    &\bar{e}(\tau) = h(\bar{x}(\tau)) - p(\bar{\theta}(\tau)) \label{eq:minProblemD}\\
    &\bar{u}(\tau) \in \mathcal{U}, \quad \bar{x}(\tau) \in \mathcal{X} \label{eq:minProblemE}\\
    &\bar{\theta}(\tau) \in [0, \theta_{max}], \quad \bar{\vartheta}(\tau) \in \mathcal{V} \label{eq:minProblemF}\\
    &h_c(\bar{x}(\tau), \bar{u}(\tau)) \leq 0 \label{eq:minProblemG}
\end{align}
\end{subequations}
\noindent Die optimalen Eingangsgrößen sind $\bar{u}^{*}(\cdot),\bar{\vartheta}^{*}(\cdot)$. Die Kostenfunktion ist definiert durch
\begin{multline}
    J(x(t_k),\theta(t_k),\bar{u}(\cdot),\bar{\vartheta}(\cdot)) = \\ \int_{t_k}^{t_k + T_p} F(\bar{e}(\tau),\bar{x}(\tau),\bar{u}(\tau),\bar{\vartheta}(\tau))d\tau + E(\bar{e}(t_k+T_p),\bar{x}(t_k+T_p))
\end{multline}
\noindent mit den Wegkosten $F(\cdot)$ und den Endkosten $E(\cdot)$:
\begin{align}
    F(e, x, u, \vartheta) &= \left\| \begin{matrix} e \\a_{lat}(x) \end{matrix} \right\|_Q^2 + \left\| \begin{matrix} u \\ \vartheta - \vartheta_{ref} \end{matrix} \right\|_R^2 \\
    E(e, x) &= \left\| \begin{matrix} e \\ a_{lat}(x) \end{matrix} \right\|_P^2
\end{align}
\noindent Die Kostenfunktionen werden durch die Diagonalmatrizen $Q$, $R$ und $P$ gewichtet:
\begin{equation}
    \begin{split}
        Q &= \operatorname{diag}(q_x, q_y, q_\psi, q_a), \\
        P &= \operatorname{diag}(p_x, p_y, p_\psi, p_a), \\
        R &= \operatorname{diag}(r_a, r_\omega, r_v),
    \end{split}
\end{equation}





Eine Methode zur Ermittlung geeigneter Parameter für das Optimierungsproblem der Pfadfolgeregelung ist in \cite{math11020465} dokumentiert. Durch eine bayes'sche Optimierung wurden Parameterwerte für eine möglichst optimale Verfolgung des Pfads und der Pfadgeschwindigkeit bei gleichzeitiger Minimierung der lateralen und longitudinalen Beschleunigungen ermittelt. Letzteres hat einen großen Einfluss auf die Wahrnehmung des Fahrkomforts \cite{BELLEM201890}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/2_Grundlagen/MPFC_Schema.png}
    \caption{schematischer Aufbau der MPFC \cite{ritschel2019}}
    \label{fig:MPFC_Schema}
\end{figure}
    
\section{Szenariobasiertes Testen im Automobilbereich} \label{sec:SoftwaretestsAutomobil}

Um ein autonomes Fahrsystem zu realisieren und Sicherheit zu gewährleisten sind ausgiebige Test- und Verifikationsprozesse erforderlich. Dabei ist es nicht mehr ausreichend, Testdaten durch reale Testfahrten auf der Straße zu sammeln. Ein großer Anteil der Daten ist schlichtweg uninteressant, da keine kritischen Fahrsituation auftreten. Es bietet sich daher an, in einer Datenbank die kritischen Szenarien zu erfassen und für spätere Verifikationsprozesse wieder heranzuziehen \cite{Nalic2020}.

Um Szenarien zu beschreiben und in eine Datenbank einordnen zu können müssen diese klassifiziert werden. Eine Möglichkeit dafür ist die Einteilung nach Informationslevel \cite{Nalic2020}\cite{Bagschik2018}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/2_Grundlagen/layer_model.png}
    \caption{Einteilung eines Szenarios nach Informationsgehalt \cite{Bagschik2018}}
    \label{fig:layer_model}
\end{figure}
Die erste Ebene definiert dabei grundlegende Eigenschaften der Straße, wie etwa deren Beschaffenheit oder Grenzen. Die nächste Ebene fügt Infrastrukturobjekte wie Straßenschilder hinzu. Ebene drei enthält Informationen über temporäre Veränderungen der darunterliegenden Ebenen. Ebene vier fügt einem Szenario statische und dynamische Objekte wie andere Verkehrsteilnehmer und Manöverplanung hinzu. Zum Schluss können noch Umweltfaktoren eingefügt werden \cite{Bagschik2018}.

Eine weitere Klassifizierungsmöglichkeit ist nach dem Abstraktionsgrad, wie in Abbildung \ref{fig:scenario_level} zu sehen ist \cite{Nalic2020}\cite{menzel2018scenarios}. Zunächst werden funktionale Szenarios beschrieben. Diese können einfach mit Worten beschrieben werden und enthalten noch keine Information über die Parameter. In einem ersten Abstrahierungsschritt werden diese zu logischen Szenarios. Hier wurden Parameter identifiziert und Grenzen für diese festgelegt. Um ein konkretes Szenario zu erhalten muss für jeden Parameter ein Wert ausgewählt werden. Theoretisch ermöglicht dies eine unendliche Anzahl an konkreten Szenarios, welche aus lediglich einem funktionalen Szenario erstellt werden können. Selbst bei rein simulativen Tests ist das nicht umsetzbar und muss reduziert werden \cite{menzel2018scenarios}.
\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/2_Grundlagen/scenario_level.pdf}
    \caption{Einteilung eines Szenarios nach Abstraktionsgrad \cite{menzel2018scenarios}}
    \label{fig:scenario_level}
\end{figure}

\section{Softwartests und Unit-Tests} \label{sec:CICD}

% Ein geeignetes Testmanagement erhöht die Qualität einer Software maßgeblich. Ein Testprozess läuft in der Regel nach dem in Abbildung \ref{fig:testprozess} dargestellten Schema ab. Für den Testprozess exitisieren die Normen IEEE 829 und ISO-Standard 9126. Das International Software Testing Qualifications Board (ISTQB) arbeitet auf Grundlage dieser Normen an der Standardisierung von Systemtests \cite{witte2019testmanagement}.
% \begin{figure}
%     \centering
%     \includegraphics[width=0.7\textwidth]{figures/2_Grundlagen/testprozess.png}
%     \caption{Ablauf eines Testprozesses \cite{witte2019testmanagement}}
%     \label{fig:testprozess}
% \end{figure}

%%%
% Unit Test Zeug
% Witte: S. 22 Testnormen: kurz ausführen, später verwenden
%%%

Ein geeignetes Testmanagement erhöht die Qualität einer Software maßgeblich, indem mehr Fehler im Entwicklungsprozess entdeckt werden und beseitigt werden können. Eine Möglichkeit Testprozesse durchzuführen steckt hinter den Schlagworten Continuous Integration (CI) und Continuous Deployment (CD). Darunter versteht sich ein Prozess zum entwickeln, testen und freigeben von Software unter Nutzung von Versionsverwaltungssoftware wie er in Abbildung \ref{fig:ci-cd-flow-desktop} dargestellt ist. Wenn ein Entwickler in einem Softwaremodul Änderungen veranlasst, läuft ein automatischer Testprozess ab. Dieser ist typischerweise in Stages unterteilt, in Abbildung \ref{fig:ci-cd-flow-desktop} sind diese BUILD, TEST, MERGE. Werden darin keine Fehler in der Software gefunden werden die Änderungen eines Moduls zusammen mit den Änderungen an allen Modulen zusammengefasst und und somit die gesamte Software auf den aktuellen Stand gebracht (Continuous Delivery). Werden für die Gesamtsoftware ebenfalls keine Fehler gefunden kann eine neue Softwareversion zum Kunden gebracht werden (Continuous Deployment). Dieser Testprozess läuft in der Regel automatisch ab und veringert die Anzahl an Fehlern in Software \cite{redhat2024}.
\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/2_Grundlagen/ci-cd-flow-desktop.png}
    \caption{Ablauf eines CI/CD Prozesses \cite{redhat2024}}
    \label{fig:ci-cd-flow-desktop}
\end{figure}